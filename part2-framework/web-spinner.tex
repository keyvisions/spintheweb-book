% Chapter 9: The Web Spinner

\chapter{The Web Spinner}
\label{chap:web-spinner}

\begin{quote}
	\textit{"The web of our life is of a mingled yarn, good and ill together."} \\
— William Shakespeare
\end{quote}

\wbdl{} is processed by a server-side engine called the \textbf{Web Spinner}. In a direct analogy to how a client-side web browser renders HTML into a user-facing webpage, the Web Spinner interprets \wbdl{} descriptions to generate and manage the web portal on the server. It is the runtime engine of the project, complemented by the \textbf{Spin the Web Studio}, which serves as the design-time tool for creating and modifying the \webbase{} itself. This architecture allows for dynamic, data-driven portal generation based on the \wbdl{} specification.

When the Web Spinner starts, it loads the \webbase{} (in JSON format) into memory. This \webbase{} is transformed into an optimized, in-memory object, allowing for fast access and manipulation of the portal's structure.

\section{Primary Roles and Responsibilities}
\label{sec:primary-roles}

The Web Spinner's primary roles are routing and content delivery:

\begin{enumerate}
	\item \textbf{URL-Based Routing:} It maps the incoming URL directly to a \webbase{} object. For example, a URL like \texttt{https://portal.acme.com/areaslug/areaslug/pageslug} is interpreted as a path to a specific \texttt{STWPage} element within the \webbase{} hierarchy.

	\item \textbf{Page Composition:} When a user requests a page, the Web Spinner acts as the initial router. It identifies the requested page and its associated \texttt{STWContent} elements. Crucially, it checks the \texttt{visibility} rules for the page and each content element against the user's roles. Elements that are not visible to the user are filtered out and never sent to the client. The spinner then returns the list of slugs for the visible contents.

	\item \textbf{Asynchronous Content Fetching:} The client receives the list of content slugs and proceeds to request each one asynchronously and individually. For instance, it would request \texttt{https://portal.acme.com/areaslug/areaslug/pageslug/contentslug}. This approach allows the main page structure to load quickly while content is fetched in parallel, improving perceived performance.

	\item \textbf{Dynamic Content:} A content element is not limited to rendering data but also managing data like an API.
\end{enumerate}

This architecture ensures that the server handles the core logic of structure, routing, and security, while the client is responsible for the final rendering, leading to a flexible and performant web portal.

\section{System Startup and Initialization}
\label{sec:system-startup}

When the Web Spinner starts up, it performs several critical initialization steps:

\subsection{Webbase Loading}

The engine loads the complete \wbdl{} document (\webbase{}) from disk, stored in JSON format. This document contains the entire portal structure, including all areas, pages, content definitions, and configuration data.

\subsection{In-Memory Optimization}

The loaded \webbase{} is parsed and transformed into an optimized in-memory object graph. This transformation includes:

\begin{itemize}
	\item Resolving all GUID references between elements
	\item Building navigation hierarchies for fast traversal
	\item Pre-compiling visibility rules for rapid role-based filtering
	\item Indexing elements by slug for efficient URL routing
\end{itemize}

\subsection{Datasource Configuration}

All datasources defined in the \texttt{STWSite} element are initialized and connection pools are established. This includes databases, \rest{} APIs, file systems, and any other external data providers.

\subsection{Route Table Generation}

A comprehensive routing table is built from the \webbase{} structure, mapping URL patterns to specific \texttt{STWPage} and \texttt{STWContent} elements.

\section{Security}
\label{sec:security}

Security in Spin the Web encompasses both \textbf{authentication} and \textbf{authorization}.

\begin{itemize}
	\item \textbf{Authentication} verifies that an entity is who it claims to be.
	\item \textbf{Authorization} determines whether an authenticated entity can access a given service.
\end{itemize}

\subsection{Authentication}

Spin the Web supports native authentication via:

\begin{itemize}
	\item \textbf{User/password pairs}
	\item \textbf{Service-based credentials} (e.g., API tokens or external identity providers)
\end{itemize}

Authenticated entities are assigned one or more roles.

\paragraph{Initial Role Assignment}
When a portal is accessed, the requester is automatically treated as a \textbf{guest user}.

\begin{itemize}
	\item The guest user is assigned the \texttt{guests} role by default.
	\item This role governs visibility for unauthenticated users.
	\item Content not explicitly visible to \texttt{guests} will return a \texttt{200 OK} with an empty response.
\end{itemize}

This ensures safe default behavior and prevents metadata leakage.

\subsection{Authorization: The Visibility Paradigm}

Authorization in Spin the Web is based on \textbf{visibility}. Content is either:

\begin{itemize}
	\item \textbf{Visible} $\to$ served to the requester
	\item \textbf{Invisible} $\to$ treated as non-existent, returning a \texttt{200 OK} with an empty response
\end{itemize}

This paradigm simplifies access control and enforces privacy by design.

\begin{figure}[H]
\centering
\resizebox{\linewidth}{!}{%
\begin{tikzpicture}[node distance=1.6cm,>=stealth,rounded corners,align=center]
	% Nodes
	\node[draw, fill=gray!10, minimum width=2.8cm] (roles) {Session Roles\\\small guests, users, ...};
	\node[draw, fill=gray!10, right=2.8cm of roles, minimum width=3.6cm] (element) {Requested Element\\\small Page / Content};
	\node[draw, fill=blue!10, below=1.8cm of element, minimum width=5.2cm] (inherit) {RBV Inheritance\\\small true / false / undefined\\inherit up to root};
	\node[draw, fill=green!10, right=3.2cm of element, minimum width=3.8cm] (filter) {Visibility Filter\\\small visible? yes/no};
	\node[draw, fill=green!20, right=2.6cm of filter, minimum width=3.4cm] (serve) {Serve Content};
	\node[draw, fill=red!10, below=1.8cm of filter, minimum width=3.8cm] (omit) {Omit from Response\\\small 200 OK, empty body};

	% Edges
	\draw[->] (roles) -- node[above] {evaluate} (element);
	\draw[->] (element) -- (inherit);
	\draw[->] (inherit) -- (filter);
	\draw[->] (filter) -- node[above] {yes} (serve);
	\draw[->] (filter) -- node[right] {no} (omit);

	% Legend
	\node[anchor=west] at ($(roles.south west)+(0,-1.0)$) {\small Role states: true (grant), false (deny), undefined (inherit)};
\end{tikzpicture}}%
\caption{Role-Based Visibility flow: roles are evaluated against element RBV with inheritance; invisible elements are omitted without error.}
\label{fig:rbv-flow}
\end{figure}

\paragraph{Role States}
Each role can be in one of three states:

\begin{description}
	\item[\texttt{true}] explicitly granted
	\item[\texttt{false}] explicitly denied
	\item[\texttt{undefined}] inherited from parent elements
\end{description}

Inheritance follows a recursive model from the content up to the site root.

\paragraph{Role Assignment}
Roles can be assigned to:
\begin{itemize}
	\item Individual contents
	\item Pages
	\item Areas
	\item Entire site
\end{itemize}
If no role is explicitly assigned, it inherits from its parent.

\paragraph{Default Role: Guests}
The \texttt{guests} role is automatically assigned to the portal home page and its contents. All other elements are invisible to guests unless explicitly made visible.

\subsection{Predefined Roles}

Spin the Web defines the following non-deletable roles:

\begin{itemize}
	\item \texttt{roots} \hfill\emph{superuser; see override below}
	\item \texttt{guests}
	\item \texttt{users}
	\item \texttt{administrators}
	\item \texttt{developers}
	\item \texttt{webmasters}
	\item \texttt{translators}
\end{itemize}

You may define additional roles as needed. A good starting point is your organizational chart.

\paragraph{Superuser override (\texttt{roots})}
The \texttt{roots} role represents a trusted superuser. When a session includes \texttt{roots}, the “no assignment found up to the site level” condition does \emph{not} cause a deny; instead, evaluation proceeds to the element’s \texttt{visible} flag. This does not change the semantics of \texttt{visible=false} (which still hides the element).

\subsection{RBV Decision Procedure}
\label{sec:rbv-decision}

With reference to Figure~\ref{fig:rbv-flow}, the Web Spinner applies Role-Based Visibility (RBV) using the following precise rules. Let \emph{roles} be the set of roles in the current session; visibility flags are tri-state \{\texttt{true}, \texttt{false}, unset\}, where unset is treated as \texttt{true}.

\paragraph{Page decision}
\begin{enumerate}
	\item If the requested page is the Home page, \textbf{ALLOW} by default.
	\item Else, if no authorization for any of the session roles is found on the page or any ancestor (page \textrightarrow{} area \textrightarrow{} site), \textbf{DENY} — \emph{unless} the session has the \texttt{roots} role, in which case continue to step 3.
	\item Else, if \texttt{page.visible} is \texttt{false}, \textbf{DENY} and \emph{navigate to the Home page}.
	\item Otherwise, \textbf{ALLOW}.
\end{enumerate}

\paragraph{Content decision (for each content on an allowed page)}
\begin{enumerate}
	\item If the content or its ancestors (page \textrightarrow{} area \textrightarrow{} site) define authorizations for the session roles:
		\begin{enumerate}
			\item If none of those authorizations evaluate to \texttt{true}, \textbf{DENY}.
			\item Else, if \texttt{content.visible} is \texttt{false}, \textbf{DENY}.
			\item Otherwise, \textbf{ALLOW}.
		\end{enumerate}
	\item If no role assignment for any session role is found all the way up to the site level, treat as an \emph{explicit deny} — \emph{unless} the session has the \texttt{roots} role, in which case evaluate \texttt{content.visible}: if \texttt{false} then \textbf{DENY}, otherwise \textbf{ALLOW}.
\end{enumerate}

\paragraph{Defaults and inheritance}
\begin{itemize}
		\item Pages are \emph{default-deny} (unless Home), requiring an explicit or inherited allow for at least one session role, and \texttt{visible} must not be \texttt{false}. If no role assignment is found all the way to the site level, treat the outcome as an \emph{explicit deny}; sessions with the \texttt{roots} role bypass this specific condition and proceed to the \texttt{visible} check.
		\item Contents without any role assignment up to the site level are \emph{explicitly denied}. Sessions with the \texttt{roots} role bypass only this condition and proceed to the \texttt{visible} check.
		\item RBV inherits up the hierarchy; evaluation short-circuits at the nearest level that defines role entries. If none are found by the time the site is reached, the result is an explicit deny (subject to the \texttt{roots} override above).
\end{itemize}

\section{User Session Management}
\label{sec:session-management}

The Web Spinner maintains stateful user sessions to manage authentication, authorization, and personalization:

\subsection{Session Establishment}

When a user first accesses the portal, a new session is created with a unique identifier; a guest user is set as the session user (assigned the \texttt{guests} role). Sessions are maintained using cookies, JWT tokens, or other mechanisms.

\subsection{Authentication Integration}

The system integrates with various authentication providers (LDAP, OAuth, SAML, etc.) to verify user credentials and establish their identity.

\subsection{Role Assignment}

Once authenticated, the user's roles are determined through integration with identity providers or internal role mappings. These roles are cached in the session for performance.

\subsection{Session State}

The session maintains:
\begin{itemize}
	\item User identity and roles
	\item Current language preference
	\item Navigation history
	\item Cached command results (when appropriate)
	\item Active datasource connections
\end{itemize}

\section{Request Routing and Processing}
\label{sec:request-routing}

The Web Spinner handles incoming HTTP requests through a sophisticated routing mechanism:

\subsection{URL Parsing}

Incoming URLs are parsed to extract the area/page/content hierarchy. For example:
\begin{itemize}
	\item \texttt{https://portal.acme.com/sales/dashboard} → Area: "sales", Page: "dashboard"
	\item \texttt{https://portal.acme.com/sales/dashboard/orders-table} → Area: "sales", Page: "dashboard", Content: "orders-table"
\end{itemize}

\subsection{Element Resolution}

Using the pre-built routing table, URLs are resolved to specific \wbdl{} elements. Runtime outcomes:
\begin{itemize}
	\item \textbf{Pages}: If the URL resolves to a page that is not visible to the current session (per Figure~\ref{fig:rbv-flow} and \secref{sec:rbv-decision}), the user is taken to the \textbf{Home page}. If the path itself is invalid, the nearest site or area main page is served.
	\item \textbf{Contents}: If a content is not visible, it is omitted entirely and the request returns \texttt{200 OK} with an empty body. If the path is invalid, no result is returned.
\end{itemize}

\subsection{Protocol Handling}

The Web Spinner supports both HTTP and WebSocket protocols:
\begin{description}
	\item[\textbf{HTTP}]: Used for standard page and content requests, following RESTful principles
	\item[\textbf{WebSocket}]: Used for real-time content updates, live data feeds, and interactive features
\end{description}

\section{Visibility and Authorization Engine}
\label{sec:authorization-engine}

Before any content is delivered, the Web Spinner performs comprehensive authorization checks. See \secref{sec:security} for the visibility model and predefined roles; this section focuses on runtime enforcement:

\subsection{Role-Based Filtering}

For each requested element (page or content), the visibility rules are evaluated against the user's session roles:
\begin{itemize}
	\item Elements with no matching role rules inherit visibility from their parent elements
	\item The hierarchical check continues up to the root element
	\item Elements without explicit or inherited visibility permissions are denied by default
\end{itemize}

\subsection{Dynamic Filtering}

Visibility checks are performed in real-time for every request, ensuring that changes to user roles or permissions take immediate effect.

\subsection{Secure Response Generation}

Only authorized elements are included in the response. Unauthorized elements are completely omitted, preventing information leakage.

\section{Content Request and Response Cycle}
\label{sec:content-cycle}

The Web Spinner handles content requests through a multi-stage process:

\subsection{Page Structure Delivery}

When a page is requested, the Web Spinner:
\begin{itemize}
	\item Identifies all visible \texttt{STWContent} elements for the page
	\item Returns a lightweight response containing the list of content slugs and their metadata
	\item Includes section assignments and sequencing information for layout
\end{itemize}

\subsection{Asynchronous Content Fetching}

The client then requests individual content elements:
\begin{itemize}
	\item Each content request triggers a separate web socket call to the Web Spinner
	\item Content elements are fetched in parallel, improving perceived performance
	\item Each content element is processed independently, allowing for granular caching and error handling
\end{itemize}

\subsection{Content Processing Pipeline}

For each content request, the Web Spinner:
\begin{enumerate}
	\item Validates user authorization for the specific content element
	\item Resolves the associated datasource and command
	\item Processes the command through the \wbpl{} (Webbase Placeholders Language) engine
	\item Executes the processed command against the datasource
	\item Applies the content layout transformation
	\item Returns the rendered content or raw data (depending on the request type)
\end{enumerate}

\section{Datasource Connection and Command Management}
\label{sec:datasource-management}

The Web Spinner maintains a sophisticated datasource management system:

\subsection{Connection Pooling}

Database and API connections are pooled and reused across requests to optimize performance and resource utilization.

\subsection{Command Processing}

Raw queries defined in \texttt{STWContent} elements undergo several processing steps:

\begin{description}
	\item[\textbf{\wbpl{} Processing}]: Placeholders are resolved using session data, URL parameters, and global variables
	\item[\textbf{Security Validation}]: Processed queries are validated to prevent injection attacks
	\item[\textbf{Optimization}]: Command plans may be cached for frequently-executed queries
\end{description}

\subsection{Multi-Datasource Support}

The system supports heterogeneous datasources:

\begin{description}
	\item[\textbf{Relational Databases}]: SQL queries with full \wbpl{} placeholder support
	\item[\textbf{\rest{} APIs}]: HTTP requests with parameter substitution and response transformation
	\item[\textbf{NoSQL Databases}]: Native command languages (MongoDB, Elasticsearch, etc.)
	\item[\textbf{File Systems}]: Direct file access and processing
\end{description}

\subsection{Error Handling}

Datasource errors are gracefully handled:
\begin{itemize}
	\item Connection failures trigger automatic retry logic
	\item Command errors are logged and appropriate error responses are returned
	\item Partial failures in multi-content pages don't affect other content elements
\end{itemize}

\section{Performance Optimization and Timeout Management}
\label{sec:performance-optimization}

The Web Spinner implements several performance and reliability features:

\subsection{Content Timeouts}

Each content element has configurable timeout settings:

\begin{description}
	\item[\textbf{Command Timeout}]: Maximum time allowed for datasource queries
	\item[\textbf{Layout Timeout}]: Maximum time for layout compilation and rendering
	\item[\textbf{Total Request Timeout}]: Overall timeout for content delivery
\end{description}

\subsection{Caching Mechanisms}

Multiple levels of caching improve performance:

\begin{description}
	\item[\textbf{Command Result Caching}]: Datasource results are cached based on command signatures
	\item[\textbf{Layout Caching}]: Compiled layouts are cached until templates change
	\item[\textbf{Response Caching}]: Complete HTTP responses may be cached for static content
\end{description}

\subsection{Load Balancing}

Multiple Web Spinner instances can operate in parallel:
\begin{itemize}
	\item Session affinity ensures consistent user experience
	\item Shared cache layers enable scaling across multiple servers
	\item Health monitoring ensures failed instances are automatically excluded
\end{itemize}

\subsection{Monitoring and Metrics}

The Web Spinner provides comprehensive monitoring:
\begin{itemize}
	\item Request/response times and throughput metrics
	\item Datasource performance and error rates
	\item User session analytics and behavior patterns
	\item System resource utilization and capacity planning data
\end{itemize}

This architecture ensures that the Web Spinner can handle enterprise-scale workloads while maintaining high performance, security, and reliability standards.

\section{Looking Forward}
\label{sec:webspinner-forward}

At this point, we have a powerful engine and a sophisticated set of languages. However, asking developers to write raw \wbdl{} in a text editor, manage resources via the command line, and test queries in a separate database tool would be laborious and inefficient. How can we streamline this development process?

This is where the \textbf{Spin the Web Studio} comes in. The Studio, itself a \webbaselet{}, provides a comprehensive, integrated development environment for building, testing, and deploying \webbase{s}. It is the testing ground for the entire Web Spinner ecosystem and an essential tool for any serious developer. The next chapter will be dedicated to exploring the Studio's rich feature set.
